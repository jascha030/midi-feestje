<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Isometric Grid Plotter</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 20px;
        padding: 15px;
        background-color: #f0f0f0;
        border-radius: 5px;
      }
      .control-group {
        display: flex;
        flex-direction: column;
        min-width: 150px;
      }
      label {
        margin-bottom: 5px;
        font-weight: bold;
      }
      input,
      select,
      button {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }
      button {
        background-color: #4caf50;
        color: white;
        border: none;
        cursor: pointer;
        transition: background-color 0.3s;
      }
      button:hover {
        background-color: #45a049;
      }
      .canvas-container {
        overflow: auto;
        border: 1px solid #ddd;
        margin-top: 20px;
        background-color: white;
      }
      canvas {
        display: block;
      }
      .color-picker {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .actions {
        display: flex;
        gap: 10px;
        margin-top: 15px;
      }
      .clear-btn {
        background-color: #f44336;
      }
      .clear-btn:hover {
        background-color: #d32f2f;
      }
      .save-btn {
        background-color: #2196f3;
      }
      .save-btn:hover {
        background-color: #0b7dda;
      }
      .plot-mode {
        display: flex;
        gap: 10px;
        margin-top: 15px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Isometric Grid Plotter</h1>

      <div class="controls">
        <div class="control-group">
          <label for="gridSize">Grid Size:</label>
          <input type="number" id="gridSize" min="5" max="50" value="20" />
        </div>

        <div class="control-group">
          <label for="cellSize">Cell Size (px):</label>
          <input type="number" id="cellSize" min="10" max="100" value="30" />
        </div>

        <div class="control-group">
          <label for="gridColor">Grid Color:</label>
          <input type="color" id="gridColor" value="#cccccc" />
        </div>

        <div class="control-group">
          <label for="bgColor">Background Color:</label>
          <input type="color" id="bgColor" value="#ffffff" />
        </div>

        <div class="control-group">
          <label for="showCoordinates">Show Coordinates:</label>
          <select id="showCoordinates">
            <option value="yes">Yes</option>
            <option value="no">No</option>
          </select>
        </div>

        <div class="control-group">
          <button id="updateGrid">Update Grid</button>
        </div>
      </div>

      <div class="plot-mode">
        <div class="control-group">
          <label for="plotMode">Plot Mode:</label>
          <select id="plotMode">
            <option value="cube">Cube</option>
            <option value="point">Point</option>
            <option value="erase">Erase</option>
          </select>
        </div>

        <div class="control-group">
          <label for="cubeColor">Cube Color:</label>
          <input type="color" id="cubeColor" value="#3498db" />
        </div>

        <div class="control-group">
          <label for="cubeHeight">Cube Height:</label>
          <input type="number" id="cubeHeight" min="1" max="10" value="1" />
        </div>
      </div>

      <div class="actions">
        <button id="clearGrid" class="clear-btn">Clear Grid</button>
        <button id="saveImage" class="save-btn">Save as Image</button>
      </div>

      <div class="canvas-container">
        <canvas id="isoGrid"></canvas>
      </div>
    </div>

    <script>
      // Main variables
      const canvas = document.getElementById("isoGrid");
      const ctx = canvas.getContext("2d");
      let gridSize = 20;
      let cellSize = 30;
      let gridColor = "#cccccc";
      let bgColor = "#ffffff";
      let showCoordinates = "yes";
      let plotMode = "cube";
      let cubeColor = "#3498db";
      let cubeHeight = 1;

      // Store plotted items
      let plottedItems = [];

      // Initialize the grid
      function initGrid() {
        // Get values from inputs
        gridSize = parseInt(document.getElementById("gridSize").value);
        cellSize = parseInt(document.getElementById("cellSize").value);
        gridColor = document.getElementById("gridColor").value;
        bgColor = document.getElementById("bgColor").value;
        showCoordinates = document.getElementById("showCoordinates").value;

        // Calculate canvas size based on isometric projection
        const width = gridSize * cellSize * 2;
        const height = gridSize * cellSize * 1.5;

        // Set canvas size
        canvas.width = width;
        canvas.height = height;

        // Draw the grid
        drawGrid();
      }

      // Convert isometric coordinates to screen coordinates
      function isoToScreen(x, y) {
        // Isometric projection
        const screenX = (x - y) * cellSize + canvas.width / 2;
        const screenY = ((x + y) * cellSize) / 2 + 50;
        return { x: screenX, y: screenY };
      }

      // Convert screen coordinates to isometric coordinates
      function screenToIso(screenX, screenY) {
        // Inverse isometric projection
        screenX = screenX - canvas.width / 2;
        screenY = screenY - 50;

        const x = (screenX / cellSize + (2 * screenY) / cellSize) / 2;
        const y = ((2 * screenY) / cellSize - screenX / cellSize) / 2;

        return {
          x: Math.round(x),
          y: Math.round(y),
        };
      }

      // Draw the isometric grid
      function drawGrid() {
        // Clear canvas
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw grid lines
        ctx.strokeStyle = gridColor;
        ctx.lineWidth = 1;

        // Draw horizontal lines (along x-axis in isometric space)
        for (let y = -gridSize; y <= gridSize; y++) {
          const start = isoToScreen(-gridSize, y);
          const end = isoToScreen(gridSize, y);

          ctx.beginPath();
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(end.x, end.y);
          ctx.stroke();

          // Draw coordinates if enabled
          if (showCoordinates === "yes" && y % 5 === 0) {
            const coord = isoToScreen(-gridSize, y);
            ctx.fillStyle = "#000";
            ctx.font = "10px Arial";
            ctx.fillText(`(x,${y})`, coord.x - 30, coord.y);
          }
        }

        // Draw vertical lines (along y-axis in isometric space)
        for (let x = -gridSize; x <= gridSize; x++) {
          const start = isoToScreen(x, -gridSize);
          const end = isoToScreen(x, gridSize);

          ctx.beginPath();
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(end.x, end.y);
          ctx.stroke();

          // Draw coordinates if enabled
          if (showCoordinates === "yes" && x % 5 === 0) {
            const coord = isoToScreen(x, -gridSize);
            ctx.fillStyle = "#000";
            ctx.font = "10px Arial";
            ctx.fillText(`(${x},y)`, coord.x, coord.y - 10);
          }
        }

        // Redraw all plotted items
        drawPlottedItems();
      }

      // Draw a cube at isometric coordinates
      function drawCube(x, y, height, color) {
        const pos = isoToScreen(x, y);
        const cubeSize = cellSize;

        // Calculate the points of the cube
        const top = { x: pos.x, y: pos.y - (height * cellSize) / 2 };

        // Draw the top face
        ctx.fillStyle = lightenColor(color, 30);
        ctx.beginPath();
        ctx.moveTo(top.x, top.y);
        ctx.lineTo(top.x + cubeSize, top.y - cubeSize / 2);
        ctx.lineTo(top.x, top.y - cubeSize);
        ctx.lineTo(top.x - cubeSize, top.y - cubeSize / 2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Draw the right face
        ctx.fillStyle = lightenColor(color, 10);
        ctx.beginPath();
        ctx.moveTo(top.x, top.y);
        ctx.lineTo(top.x + cubeSize, top.y - cubeSize / 2);
        ctx.lineTo(
          top.x + cubeSize,
          top.y + (height * cellSize) / 2 - cubeSize / 2,
        );
        ctx.lineTo(top.x, top.y + (height * cellSize) / 2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Draw the left face
        ctx.fillStyle = darkenColor(color, 10);
        ctx.beginPath();
        ctx.moveTo(top.x, top.y);
        ctx.lineTo(top.x - cubeSize, top.y - cubeSize / 2);
        ctx.lineTo(
          top.x - cubeSize,
          top.y + (height * cellSize) / 2 - cubeSize / 2,
        );
        ctx.lineTo(top.x, top.y + (height * cellSize) / 2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }

      // Draw a point at isometric coordinates
      function drawPoint(x, y, color) {
        const pos = isoToScreen(x, y);

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, cellSize / 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      }

      // Redraw all plotted items
      function drawPlottedItems() {
        plottedItems.forEach((item) => {
          if (item.type === "cube") {
            drawCube(item.x, item.y, item.height, item.color);
          } else if (item.type === "point") {
            drawPoint(item.x, item.y, item.color);
          }
        });
      }

      // Helper function to lighten a color
      function lightenColor(color, percent) {
        const num = parseInt(color.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) + amt;
        const G = ((num >> 8) & 0x00ff) + amt;
        const B = (num & 0x0000ff) + amt;

        return (
          "#" +
          (
            0x1000000 +
            (R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +
            (G < 255 ? (G < 1 ? 0 : G) : 255) * 0x100 +
            (B < 255 ? (B < 1 ? 0 : B) : 255)
          )
            .toString(16)
            .slice(1)
        );
      }

      // Helper function to darken a color
      function darkenColor(color, percent) {
        const num = parseInt(color.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) - amt;
        const G = ((num >> 8) & 0x00ff) - amt;
        const B = (num & 0x0000ff) - amt;

        return (
          "#" +
          (
            0x1000000 +
            (R > 0 ? (R < 255 ? R : 255) : 0) * 0x10000 +
            (G > 0 ? (G < 255 ? G : 255) : 0) * 0x100 +
            (B > 0 ? (B < 255 ? B : 255) : 0)
          )
            .toString(16)
            .slice(1)
        );
      }

      // Handle canvas click for plotting
      canvas.addEventListener("click", function (e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Convert screen coordinates to isometric coordinates
        const isoCoords = screenToIso(mouseX, mouseY);

        // Get current plot mode and settings
        plotMode = document.getElementById("plotMode").value;
        cubeColor = document.getElementById("cubeColor").value;
        cubeHeight = parseInt(document.getElementById("cubeHeight").value);

        // Check if we're in erase mode
        if (plotMode === "erase") {
          // Find and remove any item at this position
          plottedItems = plottedItems.filter(
            (item) => !(item.x === isoCoords.x && item.y === isoCoords.y),
          );
        } else {
          // Check if there's already an item at this position
          const existingItemIndex = plottedItems.findIndex(
            (item) => item.x === isoCoords.x && item.y === isoCoords.y,
          );

          // If there's an existing item, replace it
          if (existingItemIndex !== -1) {
            plottedItems.splice(existingItemIndex, 1);
          }

          // Add the new item
          if (plotMode === "cube") {
            plottedItems.push({
              type: "cube",
              x: isoCoords.x,
              y: isoCoords.y,
              height: cubeHeight,
              color: cubeColor,
            });
          } else if (plotMode === "point") {
            plottedItems.push({
              type: "point",
              x: isoCoords.x,
              y: isoCoords.y,
              color: cubeColor,
            });
          }
        }

        // Redraw the grid and items
        drawGrid();
      });

      // Update grid button
      document.getElementById("updateGrid").addEventListener("click", initGrid);

      // Clear grid button
      document
        .getElementById("clearGrid")
        .addEventListener("click", function () {
          plottedItems = [];
          drawGrid();
        });

      // Save as image button
      document
        .getElementById("saveImage")
        .addEventListener("click", function () {
          const link = document.createElement("a");
          link.download = "isometric-grid.png";
          link.href = canvas.toDataURL("image/png");
          link.click();
        });

      // Initialize the grid on page load
      window.onload = initGrid;
    </script>
  </body>
</html>
